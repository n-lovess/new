CHIP Decoder201830364 {
    IN A, B, C, D;
    OUT a, b, c, d, e, f, g;

    PARTS:

    // Precompute all NOT gates
    Not(in=A, out=notA);
    Not(in=B, out=notB);
    Not(in=C, out=notC);
    Not(in=D, out=notD);

    // Segment a logic
    And(a=notA, b=notB, out=term1a);
    And(a=term1a, b=notD, out=term2a);
    And(a=A, b=C, out=term3a);
    And(a=term3a, b=notB, out=term4a);
    Or(a=term2a, b=term4a, out=a);

    // Segment b logic
    And(a=notA, b=C, out=term1b);
    And(a=term1b, b=notD, out=term2b);
    And(a=B, b=C, out=term3b);
    Or(a=term2b, b=term3b, out=b);

    // Segment c logic
    And(a=notB, b=C, out=term1c);
    And(a=term1c, b=notD, out=term2c);
    Or(a=term2c, b=B, out=c);

    // Segment d logic
    And(a=notA, b=B, out=term1d);
    And(a=term1d, b=notD, out=term2d);
    And(a=A, b=C, out=term3d);
    Or(a=term2d, b=term3d, out=d);

    // Segment e logic
    And(a=notA, b=D, out=term1e);
    And(a=notB, b=C, out=term2e);
    Or(a=term1e, b=term2e, out=e);

    // Segment f logic
    And(a=A, b=notC, out=term1f);
    And(a=term1f, b=D, out=term2f);
    And(a=notB, b=C, out=term3f);
    Or(a=term2f, b=term3f, out=f);

    // Segment g logic
    And(a=notA, b=C, out=term1g);
    And(a=term1g, b=D, out=term2g);
    And(a=A, b=notC, out=term3g);
    Or(a=term2g, b=term3g, out=g);
}